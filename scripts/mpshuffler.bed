--///////////////////////////////////////////////////////////////////////////
--// MpShuffler.bed
--///////////////////////////////////////////////////////////////////////////
--// Copyright (c) 2022 Cubiq.
--// All Rights Reserved.
--//
--// Created on 01 October 2022 17:17:47
--//
--// @Author Cubiq The Creator,
--///////////////////////////////////////////////////////////////////////////


local namelist = {}
local mpModes = ""

local mpData = {}

function shuffleMpCars()
    -- MessageBox(L"Shuffled!",MESSAGEBOX_OK,ok)
    --local player = Session:GetPlayer(1)
    -- MpLoglayer.Car
    --local player2 = Session:GetPlayer(2)
    -- MpLog(ConvertFromWString(player.Car))
    --player2.Car = player.Car
    -- player2.CarValid = false
    --proceedBack()
    MpLog("cars shuffled")
end

function MpLog(text)
    W("CubiqHelp"):SetTitle(L(text))
end

function mpGetMode(mode)
    return string.find(mpModes, mode)
end

function mpGetModesConcat()
    local tbl = {}

    local mode_list = {
        { "c", "Shuffle Cars" },
        { "n", "Shuffle Names" },
        { "h", "Hidden Names" },
    }

    for i, v in ipairs(mode_list) do
        if mpCheckModes(v[1]) then
            table.insert(tbl, v[2])
        end
    end

    return (table.getn(tbl) > 0 and "Modes: " or "") .. table.concat(tbl, ", ")
end

function stringToTable(str)
    local t = {}
    for i = 1, string.len(str) do
        t[i] = str:sub(i, i)
    end
    return t
end

function mpCheckModes(modes)
    for i, mode in ipairs(stringToTable(modes)) do
        if mpGetMode(mode) ~= nil then
            return true
        end
    end
    return false
end

function toggleMpMode(mode, state)
    state = state == nil and mpGetMode(mode) == nil
    mpModes = state and mpModes .. mode or mpModes:gsub(mode, "")
end

function setMpModes(modes, state)
    for i, mode in ipairs(stringToTable(modes)) do
        toggleMpMode(mode, state)
    end
    MpLog(mpGetModesConcat())
    proceedBack()
end

function applyMpModes()
    -- check and apply the modes: (shuffle cars, hide player names, shuffle names)
    local mode_list = {
        { "c", function() shuffleMpCars() end },
        { "n", function() shuffleMpNames() end },
        { "h", function() hideMpNames() end },
    }
    -- local mode_list = {
    --     {"c"},
    --     {"n"},
    --     {"h"},
    -- }
    local m = ""
    for i, v in ipairs(mode_list) do
        if mpCheckModes(v[1]) then
            -- v[2]()
            m = m .. v[1] .. v[1]
            v[2]()
        end
    end
    --MpLog(m)
end

-- function shuffleMpCars()
--     for i = 1, Session:GetNumPlayers(), 1 do
--         local player = Session:GetPlayer(i)
--     end
--     proceedBack()
-- end

local textstr = ""

local function sendChatText()
    local textchat = Session:GetTextChat()

    local numlines = textchat:GetNumLines()

    --textchat:Update(0)
    textchat:AddLocalLine(L(textstr), Session:GetLocalPlayer(1).UId)
    -- textchat:AddLocalLine(L(string.len(textchat:GetLineText(numlines))), Session:GetLocalPlayer(1).UId)
    textchat:AddLocalLine(L(tostring(Session:GetLocalPlayer(1).UId)), Session:GetLocalPlayer(1).UId)
    textstr = textstr .. "I"
end

local function savePlayerStates()
    -- prints all players to chat
    local textchat = Session:GetTextChat()
    textchat:AddLocalLine(L "savingLobbyState:", Session:GetLocalPlayer(1).UId)
    textchat:AddLocalLine(L "<endStats>", Session:GetLocalPlayer(1).UId)
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(Session:GetNumPlayers() - i + 1)
        local name = ConvertFromWString(player.Name)
        local car = player.CarValid and player.Car or -1
        local skin = player.CarSkin

        textchat:AddLocalLine(
            L(name .. ";" .. car .. ";" .. skin),
            Session:GetLocalPlayer(1).UId
        )
    end
    textchat:AddLocalLine(L "<startStats>", Session:GetLocalPlayer(1).UId)
end

function saveMpStateData()
    -- triggered before the game start
    savePlayerStates()
    -- MpLog("successfully saved all the players!")
    applyMpModes()
    --proceedBack()
end

local function saveNames()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        namelist[i] = ConvertFromWString(player.Name)
    end
end

function revertMpNames()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        if namelist[i] ~= nil then
            player.Name = L(namelist[i])
        end
    end
    namelist = {}
    MessageBox(L "Reverted!", MESSAGEBOX_OK, ok)
    -- proceedBack()
end

function getAvailableData(db, idx)
    local names = {}
    for i = 1, table.getn(db), 1 do
        if db[i][idx] ~= nil then
            table.insert(names, db[i][idx])
        end
    end
    return names
end

function shuffleMpNames()
    saveNames()
    -- local availablenames = getAvailableData(mpData, 1)
    local availablenames = { unpack(namelist) }


    -- MpLog(table.concat(availablenames, ", "))

    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        local rndid = math.random(1, table.getn(availablenames))
        -- check if the name is not the same as the player's name

        player.Name = L(availablenames[rndid])
        table.remove(availablenames, rndid)
    end
    --MessageBox(L "Shuffled!", MESSAGEBOX_OK, ok)
    -- proceedBack()
end

function hideMpNames()
    --saveNames()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        player.Name = L(" ")
    end
    --MessageBox(L "Hidden!", MESSAGEBOX_OK, ok)
    --proceedBack()
end

function clearChat()
    -- sort of clear chat by sending a lot of empty lines
    local textchat = Session:GetTextChat()
    for i = 1, 160, 1 do
        textchat:AddLocalLine("", Session:GetLocalPlayer(1).UId)
    end
    --TODO: get chat messages and add them after the clear (with the right player.uid)
    --MessageBox(L "Cleared!", MESSAGEBOX_OK, ok)
end

-- local dataTestText = ""

function getPlayerData(txt)
    local mpD = {}
    for d in txt:gmatch("([^;]+)") do
        table.insert(mpD, d)
    end

    return mpD

    --dataTestText = "<start> "..table.concat(mpD, ",").." <end>\n"..dataTestText
    --MpLog(dataTestText)
    --local tbl = txt:gmatch("([^;]+)")
    --table.insert(mpData,  tbl )
end

function concatAllPlayerData(tbl)
    -- given 2 dimensional table, return concatenated string
    local str = ""
    for i = 1, table.getn(tbl), 1 do
        str = str .. table.concat(tbl[i], ";") .. "\n"
    end
    return str
end

function getMpDataFromChat()
    local textchat = Session:GetTextChat()
    local numlines = textchat:GetNumLines()
    local line = 0
    local lineText = ""
    local strTxt = ""
    while (lineText ~= "<endStats>") do
        line = line + 1
        if line > 1 then
            strTxt = lineText .. "\n" .. strTxt
            table.insert(mpData, getPlayerData(lineText))
        end
        lineText = (ConvertFromWString(textchat:GetLineText(numlines - line)))
    end


    --clearChat()
end

function applyValidMpData()
    -- apply the mpData to the players
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        player.Name = L(mpData[i][1])
        if tonumber(mpData[i][2]) == -1 then
            player.CarValid = false
            player.Car = 0
        else
            player.CarValid = true
            player.Car = tonumber(mpData[i][2])
            player.CarSkin = tonumber(mpData[i][3])
        end
    end
end

function checkChatData()
    if table.getn(mpData) > 0 then
        if table.getn(mpData) == Session:GetNumPlayers() then
            MpLog("valid data loaded: (" .. table.getn(mpData) .. " Players)")
        else
            -- this might happen if the player (that's saved in the chat) leaves the lobby or new players join
            MpLog("wrong data currently loaded:\n" .. concatAllPlayerData(mpData))
            -- TODO: message that the data is wrong, load even the corrupted data? y/n
        end
        return
    end
    mpData = {}
    dataTestText = ""
    MpLog("Checking chat data...")
    local textchat = Session:GetTextChat()
    local numlines = textchat:GetNumLines()

    -- TODO: check for all the lines in chat, not just the lowest one
    local txt = ConvertFromWString(textchat:GetLineText(numlines))
    MpLog("Checking chat data: '" .. string.len(txt) .. ", " .. txt .. "'")

    if txt == "<startStats>" then
        MpLog("Chat data found!")
        getMpDataFromChat()

        if table.getn(mpData) == Session:GetNumPlayers() then
            MpLog("found data of " .. table.getn(mpData) .. " Players:\n" .. concatAllPlayerData(mpData))
            checkChatData()
            applyValidMpData()
            return
        end
    else
        MpLog("Chat data not found!")
    end
end

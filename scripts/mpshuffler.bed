--///////////////////////////////////////////////////////////////////////////
--// MpShuffler.bed
--///////////////////////////////////////////////////////////////////////////
--// Copyright (c) 2022 Cubiq.
--// All Rights Reserved.
--//
--// Created on 01 October 2022 17:17:47
--//
--// @Author Cubiq The Creator,
--///////////////////////////////////////////////////////////////////////////


--[[
    t: "clear chat"  
    f: "force shuffle"  
    c: "car shuffle"  
    n: "name shuffle"  
    h: "hide names"  
--]]
local mpModes = "t" 

local mpData = {}

local namelist = {}
local carlist = {}


--// ---------------------------------------------------------------------------------------------------------------------------------
--//	local functions 
--// ---------------------------------------------------------------------------------------------------------------------------------


local function MpLog(text)
    -- simple logger window
    local w = W("ShufflerInfo")
    if w then w:SetTitle(L(text)) end
end

local function storeCarsLocally()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        carlist[i] = {}
        carlist[i][1] = player.CarValid and player.Car or -1
        carlist[i][2] = player.CarSkin
    end
end

local function storeNamesLocally()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        namelist[i] = ConvertFromWString(player.Name)
    end
end

local function mpGetMode(mode)
    return string.find(mpModes, mode)
end


--// ---------------------------------------------------------------------------------------------------------------------------------
--//	MP Modes
--// ---------------------------------------------------------------------------------------------------------------------------------

local function shuffleMpCars()
    storeCarsLocally()
    local availablecars = { unpack(carlist) }
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        local rndid
        repeat
            rndid = math.random(1, table.getn(availablecars))
        until (not(mpCheckModes("f") and rndid == i))

        player.Car = availablecars[rndid][1]
        player.CarSkin = availablecars[rndid][2]
        table.remove(availablecars, rndid)
    end
end

local function shuffleMpNames()
    storeNamesLocally()
    local availablenames = { unpack(namelist) }
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        local rndid
        repeat
            rndid = math.random(1, table.getn(availablenames))
        until (not(mpCheckModes("f") and rndid == i))

        player.Name = L(availablenames[rndid])
        table.remove(availablenames, rndid)
    end
    --MessageBox(L "Shuffled!", MESSAGEBOX_OK, ok)
    -- proceedBack()
end

local function hideMpNames()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        player.Name = L(" ")
    end
    --MessageBox(L "Hidden!", MESSAGEBOX_OK, ok)
    --proceedBack()
end

local function mpGetModesConcat()
    local tbl = {}

    local mode_list = {
        { "f", "Force Shuffle" },
        { "c", "Shuffle Cars" },
        { "n", "Shuffle Names" },
        { "h", "Hidden Names" },
    }

    for i, v in ipairs(mode_list) do
        if mpCheckModes(v[1]) then
            table.insert(tbl, v[2])
        end
    end

    return (table.getn(tbl) > 0 and "Modes: " or "") .. table.concat(tbl, ", ")
end

local function stringToTable(str)
    -- splits string to letters and returns it in table	
    local t = {}
    for i = 1, string.len(str) do
        t[i] = str:sub(i, i)
    end
    return t
end



local function toggleMpMode(mode, state)
    state = state == nil and mpGetMode(mode) == nil
    mpModes = state and mpModes .. mode or mpModes:gsub(mode, "")
end


local function applyMpModes()
    -- check and apply the modes: (shuffle cars, hide player names, shuffle names)
    local mode_list = {
        { "c", function() shuffleMpCars() end },
        { "n", function() shuffleMpNames() end },
        { "h", function() hideMpNames() end },
    }
    local m = ""
    for i, v in ipairs(mode_list) do
        if mpCheckModes(v[1]) then
            v[2]()
        end
    end
end

local function savePlayerStates()
    -- prints all players to chat
    local textchat = Session:GetTextChat()
    textchat:AddLocalLine(L "savingLobbyState:", Session:GetLocalPlayer(1).UId)
    textchat:AddLocalLine(L "<endStats>", Session:GetLocalPlayer(1).UId)
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(Session:GetNumPlayers() - i + 1)
        local name = ConvertFromWString(player.Name)
        local car = player.CarValid and player.Car or -1
        local skin = player.CarSkin

        textchat:AddLocalLine(
            L(name .. ";" .. car .. ";" .. skin),
            Session:GetLocalPlayer(1).UId
        )
    end
    textchat:AddLocalLine(L "<startStats>", Session:GetLocalPlayer(1).UId)
end

local function clearChat()
    -- sort of clear chat by sending a lot of empty lines
    local textchat = Session:GetTextChat()
    for i = 1, 160, 1 do
        textchat:AddLocalLine("", Session:GetLocalPlayer(1).UId)
    end
    -- / / MpLog("Chat cleared")
    --TODO: get chat messages and add them after the clear (with the right player.uid)
    --MessageBox(L "Cleared!", MESSAGEBOX_OK, ok)
end

-- local dataTestText = ""

local function getPlayerData(txt)
    -- gets the player data from the chat
    local pd = {}
    for v in txt:gmatch("([^;]+)") do
        table.insert(pd, v)
    end

    return pd
end

local function concatAllPlayerData(tbl)
    -- given 2 dimensional table, return concatenated string
    local str = ""
    for i = 1, table.getn(tbl), 1 do
        str = str .. table.concat(tbl[i], ";") .. "\n"
    end
    return str
end

local function getMpDataFromChat()
    local textchat = Session:GetTextChat()
    local numlines = textchat:GetNumLines()
    local line = 0
    local lineText = ""
    local strTxt = ""
    while (lineText ~= "<endStats>") do
        line = line + 1
        if line > 1 then
            strTxt = lineText .. "\n" .. strTxt
            table.insert(mpData, getPlayerData(lineText))
        end
        lineText = (ConvertFromWString(textchat:GetLineText(numlines - line)))
    end
end

local function applyValidMpData()
    -- apply the mpData to the players

    for i, v in ipairs(mpData) do
        local player = Session:GetPlayer(i)
        player.Name = L(v[1])
        if tonumber(v[2]) == -1 then
            player.CarValid = false
            player.Car = 0
        else
            player.CarValid = true
            player.Car = tonumber(v[2])
            player.CarSkin = tonumber(v[3])
        end
    end
    
    if mpCheckModes("t") then clearChat() end
end

--// ---------------------------------------------------------------------------------------------------------------------------------
--//	Public Functions
--// ---------------------------------------------------------------------------------------------------------------------------------

function mpCheckModes(modes)
    for i, mode in ipairs(stringToTable(modes)) do
        if mpGetMode(mode) ~= nil then
            return true
        end
    end
    return false
end

function setMpModes(modes, state)
    for i, mode in ipairs(stringToTable(modes)) do
        toggleMpMode(mode, state)
    end
    MpLog(mpGetModesConcat())
    proceedBack()
end

function saveMpStateData()
    -- triggered before the game start
    savePlayerStates()
    -- / / MpLog("successfully saved all the players!")
    applyMpModes()
    --proceedBack()
end

function checkChatData()
    if table.getn(mpData) > 0 then
        if table.getn(mpData) == Session:GetNumPlayers() then
            -- / / MpLog("valid data loaded: (" .. table.getn(mpData) .. " Players)")
        else
            -- this might happen if the player (that's saved in the chat) leaves the lobby or new players join
            -- / / MpLog("stored data are not right:\n" .. concatAllPlayerData(mpData))
        end
        return
    end
    mpData = {}
    dataTestText = ""
    -- / / MpLog("Checking chat data...")
    local textchat = Session:GetTextChat()
    local numlines = textchat:GetNumLines()

    -- TODO: check for all the lines in chat, not just the lowest one
    local txt = ConvertFromWString(textchat:GetLineText(numlines))
    -- / / MpLog("Checking chat data: '" .. string.len(txt) .. ", " .. txt .. "'")

    if txt == "<startStats>" then
        -- / / MpLog("Chat data found!")
        getMpDataFromChat()

        if table.getn(mpData) == Session:GetNumPlayers() then
            -- / / MpLog("found data of " .. table.getn(mpData) .. " Players:\n" .. concatAllPlayerData(mpData))
            checkChatData()
            applyValidMpData()
            return
        else
            -- this might happen if the player (that's saved in the chat) leaves the lobby or new players join
            -- / / MpLog("wrong data currently loaded:\n" .. concatAllPlayerData(mpData))
            -- TODO: message that the data is wrong, load even the corrupted data? y/n
        end
    else
        -- / / MpLog("Chat data not found!")
    end
end

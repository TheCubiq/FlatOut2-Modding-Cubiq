--///////////////////////////////////////////////////////////////////////////
--// MpShuffler.bed
--///////////////////////////////////////////////////////////////////////////
--// Copyright (c) 2022 Cubiq.
--// All Rights Reserved.
--//
--// Created on 01 October 2022 17:17:47
--//
--// @Author Cubiq The Creator,
--///////////////////////////////////////////////////////////////////////////


-- local namelist = {}
local mpModes = ""

local mpData = {}

-- function shuffleMpCars()
--     -- MessageBox(L"Shuffled!",MESSAGEBOX_OK,ok)
--     local player = Session:GetPlayer(1)
--     -- MpLoglayer.Car
--     local player2 = Session:GetPlayer(2)
--     MpLog(ConvertFromWString(player.Car))
--     player2.Car = player.Car
--     -- player2.CarValid = false
--     proceedBack()
-- end

function MpLog(text)
    W("CubiqHelp"):SetTitle(L(text))
end

function mpGetMode(mode)
    return string.find(mpModes, mode)
end

function stringToTable(str)
    local t = {}
    for i = 1, string.len(str) do
        t[i] = str:sub(i, i)
    end
    return t
end

function mpCheckModes(modes)
    for i, mode in ipairs(stringToTable(modes)) do
        if mpGetMode(mode) ~= nil then
            return true
        end
    end
    return false
end

function toggleMpMode(mode, state)
    state = state == nil and mpGetMode(mode) == nil 
    mpModes = state and mpModes .. mode or mpModes:gsub(mode, "")
end

function setMpModes(modes, state)
    for i, mode in ipairs(stringToTable(modes)) do
        toggleMpMode(mode, state)
    end
    MpLog(mpModes)
    proceedBack()
end

function applyMpModes()
    -- check and apply the modes: (shuffle cars, hide player names, shuffle names) 
end

function shuffleMpCars()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
    end
    proceedBack()
end

local textstr = ""

local function sendChatText()
    local textchat = Session:GetTextChat()

    local numlines = textchat:GetNumLines()

    --textchat:Update(0)
    textchat:AddLocalLine(L(textstr), Session:GetLocalPlayer(1).UId)
    -- textchat:AddLocalLine(L(string.len(textchat:GetLineText(numlines))), Session:GetLocalPlayer(1).UId)
    textchat:AddLocalLine(L(tostring(Session:GetLocalPlayer(1).UId)), Session:GetLocalPlayer(1).UId)
    textstr = textstr .. "I"
end

local function savePlayerStates()
    -- prints all players to chat
    local textchat = Session:GetTextChat()
    textchat:AddLocalLine(L"savingLobbyState:", Session:GetLocalPlayer(1).UId)
    textchat:AddLocalLine(L"<endStats>", Session:GetLocalPlayer(1).UId)
    for i = 1, Session:GetNumPlayers(), 1 do
       local player = Session:GetPlayer(Session:GetNumPlayers()-i+1)
       local name = ConvertFromWString(player.Name)
       local car = player.CarValid and player.Car or -1
       local skin = player.CarSkin

       textchat:AddLocalLine(
           L(name .. ";" .. car .. ";" .. skin),
           Session:GetLocalPlayer(1).UId
       )
    end
    textchat:AddLocalLine(L"<startStats>", Session:GetLocalPlayer(1).UId)
end

function saveMpStateData()
    -- triggered before the game start
    savePlayerStates()
    -- MpLog("successfully saved all the players!")
    --applyMpMode()
    --proceedBack()
end

local function saveNames()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        namelist[i] = ConvertFromWString(player.Name)
    end
end

function revertMpNames()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        if namelist[i] ~= nil then
            player.Name = L(namelist[i])
        end
    end
    namelist = {}
    MessageBox(L "Reverted!", MESSAGEBOX_OK, ok)
    proceedBack()
end

function shuffleMpNames()
    saveNames()
    local availablenames = { unpack(namelist) }
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        local rndid = math.random(1, table.getn(availablenames))
        -- check if the name is not the same as the player's name

        player.Name = L(availablenames[rndid])
        table.remove(availablenames, rndid)
    end
    MessageBox(L "Shuffled!", MESSAGEBOX_OK, ok)
    proceedBack()
end

function hideMpNames()
    saveNames()
    for i = 1, Session:GetNumPlayers(), 1 do
        local player = Session:GetPlayer(i)
        player.Name = L(" ")
    end
    MessageBox(L "Hidden!", MESSAGEBOX_OK, ok)
    proceedBack()
end


function clearChat()
    -- sort of clear chat by sending a lot of empty lines
    local textchat = Session:GetTextChat()
    for i = 1, 160, 1 do
        textchat:AddLocalLine("", Session:GetLocalPlayer(1).UId)
    end
    --TODO: get chat messages and add them after the clear (with the right player.uid)
    --MessageBox(L "Cleared!", MESSAGEBOX_OK, ok)
end

-- local dataTestText = ""

function getPlayerData(txt)
    local mpD = {}
    for d in txt:gmatch("([^;]+)") do 
        table.insert(mpD, d)
    end

    return mpD

    --dataTestText = "<start> "..table.concat(mpD, ",").." <end>\n"..dataTestText
    --MpLog(dataTestText)
    --local tbl = txt:gmatch("([^;]+)")
    --table.insert(mpData,  tbl )
end

function concatAllPlayerData(tbl)
    -- given 2 dimensional table, return concatenated string
    local str = ""
    for i = 1, table.getn(tbl), 1 do
        str = str .. table.concat(tbl[i], ";") .. "\n"
    end
    return str
end

function getMpDataFromChat()
    local textchat = Session:GetTextChat()
    local numlines = textchat:GetNumLines()
    local line = 0
    local lineText = ""
    local strTxt = ""
    while(lineText ~= "<endStats>") 
    do
        line = line + 1
        if line > 1 then 
            strTxt = lineText .. "\n" .. strTxt
            table.insert(mpData, getPlayerData(lineText))
        end
        lineText = (ConvertFromWString(textchat:GetLineText(numlines-line)))
    end

    
    --clearChat()
end


function checkChatData()
    if table.getn(mpData) > 0 then
        if table.getn(mpData) == Session:GetNumPlayers() then 
            -- TODO: load the backed up mpData here
            MpLog("valid data loaded: ("..table.getn(mpData).." Players)")
        else
            -- this might happen if the player (that's saved in the chat) leaves the lobby or new players join
            MpLog("wrong data currently loaded:\n"..concatAllPlayerData(mpData))
            -- TODO: message that the data is wrong, load even the corrupted data? y/n
        end
        return 
    end
    mpData = {}
    dataTestText = ""
    MpLog("Checking chat data...")
    local textchat = Session:GetTextChat()
    local numlines = textchat:GetNumLines()

    -- TODO: check for all the lines in chat, not just the lowest one
    local txt = ConvertFromWString(textchat:GetLineText(numlines))
    MpLog("Checking chat data: '"..string.len(txt)..", " .. txt.. "'")

    if txt == "<startStats>" then
        MpLog("Chat data found!")
        getMpDataFromChat()

        if table.getn(mpData) == Session:GetNumPlayers() then
            MpLog("found data of "..table.getn(mpData).." Players:\n"..concatAllPlayerData(mpData))
            checkChatData()
            return
        end
    else
        MpLog("Chat data not found!")
    end
end
